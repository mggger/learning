# 行为模式


## chain of responsibility 职责链

意图: 使多个对象都有机会处理请求， 从而避免请求的发送者和接收者之间的耦合关系。 

适用性:

- 有多个的对象可以处理一个请求， 那个对象处理该请求运行时刻自动确定
- 可处理一个请求的对象集合应被动态指定.

可以参考 nginx通过函数调用链实现模块化


## command 命令

意图: 将一个请求封装为一个对象， 从而使你可用不同的请求对客户进行参数化； 对请求排队或记录请求日志， 以及支持可撤销的操作。

适用性:

- 抽象出待执行的动作以参数化某对象。
- 在不同的时刻指定， 排列和执行请求。
- 支持取消操作
- 支持修改日志
- 用构建在原语操作上的高层操作构造一个系统。


## ITERATOR 迭代器

意图: 提供一种方法顺序访问一个聚合对象中各个元素， 而友不需要暴露该对象的内部表示

适用性：

- 访问一个聚合对象的内容而无需暴露它的内部表示
- 支持对聚合对象的多种遍历
- 为遍历不同的聚合结构提供一个统一的接口

## MEDIATOR 中介者

意图： 用一个中介对象来封装一系列的对象交互。 中介者使各对象不需要显式地相互引用， 从而使其耦合松散，而且可以独立地改变它们之间的交互.

适用性:

- 一组对象以定义良好但是复杂的方式进行通信
- 一个对象引用其他很多对象并且直接与这些对象通信， 导致难以复用该对象
- 想定制一个分布在多个类中的行为, 而又不想生成太多的子类.


## MEMENTO 备忘录

意图: 在不破外封装性的前提下， 捕获一个对象的内部状态， 并在该对象之外保持这个状态. 这样以后就可将该对象恢复到原先保存的状态

适用性:

- 必须保存一个对象在某一个时刻的状态， 这样以后需要时它才能恢复到先前的状态
- 如果一个用接口来让其他对象直接得到这些状态， 将会暴露对象的实现细节并破坏对象的封装性.


## OBSERVER 观察者
意图: 定义对象间的一种一对多的依赖关系， 当一个对象的状态发生改变时， 所有依赖于它的对象都得到通知并被自动更新

适用性:

- 当一个抽象模型有两个方面， 其中一个方面依赖于另一个方面。将这两者封装在独立的对象中以使它们可以独立地改变和复用
- 当对一个对象的改变需要同时改变其他对象， 而不知道具体有多少对象有待改变.
- 当一个对象必须通知其他对象, 而它又不能假定其他对象是谁.

## STATE 状态  

意图: 允许一个对象在其内部状态改变时改变它的行为， 对象看起来似乎修改了它的类。

- 一个对象的行为取决于它的状态， 并且它必须在运行时刻根据状态改变它的行为
- 一个操作中含有庞大的多分支的条件语句， 且这些分支依赖于该对象的状态。

## STRATEGY 策略

定义一系列的算法， 把它们一个个封装起来， 并且使它们可相互替换。

适用性:
- 许多相关的类仅仅是行为有异.
- 需要使用一个算法的不同变体.
- 算法使用客户不应该知道的数据
- 一个类定义了多种行为， 并且这些行为在这个类的操作中以多个条件语句的形式出现。

## template method (模版方法)

定义一个操作中的算法的骨架， 而将一些步骤延迟到子类中.


适用于下列情况:

- 一次性实现了一个算法的不变的部分， 并将可行的行为留给子类来实现
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。
- 控制子类扩展


## VISITOR 访问者
表示一个作用于某对象结构中的各元素的操作。

适用性:

- 一个对象结构包含很多类对象, 它们有不同的接口
- 需要对一个对象结构中的对象进行很多不同的并且不相关的操作
- 定义对象结构的类很少改变， 但经常要在此结构上定义新的操作。

