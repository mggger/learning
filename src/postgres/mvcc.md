# 事务访问通过MVCC


postgre 通过```xmin```和```xmax```来维护事务的生命周期

可通过下面sql进行查看 
```sql 
select xmin， xmax ... from ... 
```

它允许每个数据库客户端会话对表进行更改，但在事务提交之前，它们不会对其他会话可见。

举例来说: 

现在有两个客户端A， B 对表foo进行操作

```sql
select xmin, xmax, * from foo;
```

|xmin|xmax|id|value|
|:--|:--|:--|:--|
|830|0|1|1|


A的操作
```sql
Begin;

update test set value = 2 where id = 1;

select xmin, xmax, * from foo;

```

A的操作此时没有提交， 结果是

|xmin|xmax|id|value|
|:--|:--|:--|:--|
|832|0|1|2|

而B此时去访问， 结果仍然是原始数据， 不同的是xmax.

|xmin|xmax|id|value|
|:--|:--|:--|:--|
|830|832|1|1|


**一旦一个会话启动一个事务，它就会对在该点之后对数据库进行的大多数更改视而不见，并且它自己的更改在提交之前保持私有状态。甚至那些不被认为是最终的，即使在你回滚其交易时进行更改的会话中，原始值仍然可以更好地返回**


## 行锁冲突

第一个会话有一个打开的事务， 如果我们在第二个会话执行相同的操作会导致行锁冲突， 这个statement会挂起。

postgre 通过```Read Commited``` 模式来解决冲突.  服务器要做的是重新计划使用新副本来进行原始工作， 如果使用子句选择旧副本， 将检查新副本是否满足条件， 如果没有， 忽略新副本， 该子句不再找到它， 如果更新该行的对所有的前提都适用， 计划的更新将针对修改后的副本执行.

比如两条sql
```sql
update test set value = 2 where id = 1;
update test set value = value + 1 where id = 1;     # read value = 2  commited; 
```

结果```value=3```


另外一种模式是 ```Serialization``` 通过序列化执行指令.

### 优缺点

- 它可以避免锁定许多可能阻止其他客户端执行其工作的资源。运行查询和读取数据所需的锁与写入数据库所需的锁不冲突
- 可能会因不同会话之间的交互产生一些状况， 比如删除某张票， 另一个会话还能查询的到.
